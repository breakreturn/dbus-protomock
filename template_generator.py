

# Copyright (C) 2016 Joakim Gross
#
# Permission to use, copy, modify, and/or distribute this software for
# any purpose with or without fee is hereby granted, provided that the
# above copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
# WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR
# BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES
# OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
# ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
# SOFTWARE.

# For further information see LICENSE


"""Creates python-dbusmock templates based on D-Bus introspection XML."""

from xml.dom import minidom
import json

# Template for the complete python-dbusmock template
template_template = '''
# This file has been generated to be used as a template with python-dbusmock.
# Do not edit this file manually, instead use introspection XML and data 
# associations json to generate it differently.

# These variables are required by python-dbusmock
BUS_NAME = "{bus_name}"
MAIN_OBJ = "{main_obj}"
MAIN_IFACE = "{main_iface}"
SYSTEM_BUS = {system_bus}


def load(mock, parameters):
    """This method is required by python-dbusmock"""

{methods_section}
'''

# Template for the methods section within the 'template_template'
methods_section_template = '''    mock.AddMethods(MAIN_IFACE, [
        ("{method_name}", "{in_args}", "{out_args}", {triple_quotes}{ret}{triple_quotes}),
    ])
'''

# Template for the 'ret' value inside the 'methods_section_template'
ret_template = '''ret = eval("{{{data_associations}}}")[{key}]'''

# Template for each of the parts in the 'data_associations' within 'ret_template'
entry_template = '''{key}: {value}'''


class Template(object):
    """Creates a generated python-dbusmock template.

    An Introspected object is used to insert values into format strings.

    TODO:
    * How to deal with more than one potential value for
      BUS_NAME or MAIN_IFACE?
    """

    def __init__(self, introspected):
        self.__introspected = introspected
        self.__methods = introspected.methods()

    def apply_data_associations(self, associations):
        for method in self.__methods:
            for association in associations:
                if method.name() == association.method_name():
                    method.apply_associations(association)

    def create_template(self):
        """Returns a string with the generated template python code"""
        methods_section = ""
        data_associations_section = ""
        for method in self.__methods:
            values = {
                "method_name": method.name(),
                "in_args": method.in_args(),
                "out_args": method.out_args()
            }
            values["ret"] = method.stub()
            values["triple_quotes"] = "'''"
            methods_section += methods_section_template.format(**values)

        template_values = {
            "bus_name": self.__introspected.interface_names()[0],
            "main_obj": self.__introspected.node_name(),
            "main_iface": self.__introspected.interface_names()[0],
            "system_bus": False,
            "methods_section": methods_section
        }

        return template_template.format(**template_values)

class Method(object):
    """Represents a method created from introspection data."""

    def __init__(self, method_name, in_args=None, out_args=None):
        self.__name = method_name
        self.__in_args = in_args
        self.__out_args = out_args
        self.__stub = None

    def name(self):
        return self.__name

    def in_args(self):
        return self.__in_args

    def out_args(self):
        return self.__out_args

    def stub(self):
        return self.__stub

    def apply_associations(self, a):
        entries = ""
        for input, output in a.associations():
            # If the input is a single string we need to insert quotes
            if type(input) is unicode or type(input) is str:
                input = "\'" + input + "\'"
            if type(output) is unicode or type(output) is str:
                output = "\'" + output + "\'"
            d = {
                "key": input,
                "value": output
            }
            entry = entry_template.format(**d)
            entries += entry + "\n"
        entries = self.__insert_commas(entries)
        # If the input is a single value we use only the value as key, otherwise a tuple is used
        if self.__in_args is None or len(self.__in_args) == 1:
            key = "args.pop()"
        else:
            key = "tuple(args)"
        values = {
            "data_associations": entries,
            "key": key
        }
        if len(self.__out_args) == 0:
            self.__stub = "ret = None"
        else:
            values_formatted = ret_template.format(**values)
            self.__stub = values_formatted

    def __insert_commas(self, entries):
        return entries.replace("\n", ",")[:-1]


class Introspected(object):
    """Represents an introspected service.

    This class parses introspection data and serves as an abstraction of
    the introspection data for the user.
    """

    def __init__(self, data):
        data = minidom.parseString(data)
        self.__ifaces = self.__get_interface_names(data)
        self.__node = self.__get_node_name(data)
        self.__methods = self.__get_methods(data)

    def interface_names(self):
        return self.__ifaces

    def node_name(self):
        return self.__node

    def methods(self):
        return self.__methods.values()

    def method_by_name(self, name):
        method = None
        try:
            method = self.__methods[name]
        except:
            print "No method exist with name:", name
        return method

    def __get_interface_names(self, data):
        names = list()
        for iface in data.getElementsByTagName("interface"):
            names.append(iface.attributes["name"].value)
        return names

    def __get_node_name(self, data):
        name = data.getElementsByTagName("node")[0]
        return name.attributes["name"].value

    def __get_methods(self, data):
        """Returns a dict of Method objects"""
        methods = dict()
        for method in data.getElementsByTagName("method"):
            name = method.attributes["name"].value
            in_args = ""
            out_args = ""
            for arg in method.getElementsByTagName("arg"):
                if arg.attributes["direction"].value == "out":
                    out_args += arg.attributes["type"].value
                if arg.attributes["direction"].value == "in":
                    in_args += arg.attributes["type"].value
            m = Method(name, in_args=in_args, out_args=out_args)
            methods[name] = m
        return methods


def create_associations(data):
    """Create one DataAssociation object per method."""
    data = json.loads(data)
    data_associations = list()
    for interface, associations in data.iteritems():
        for method in associations:
            name = method["name"]
            data = method["data"]
            repacked = list()
            for pair in data:
                # Only create a tuple if input is more than one value
                if len(pair[0]) == 1:
                    input = pair[0].pop()
                else:
                    input =  tuple(pair[0])
                if len(pair[1]) > 0:
                    output = pair[1].pop()
                else:
                    output = list()
                repacked.append([input, output])
            a = DataAssociation(name, repacked)
            data_associations.append(a)
    return data_associations


class DataAssociation(object):

    def __init__(self, method_name, associations):
        self.__method_name = method_name
        self.__associations = associations

    def method_name(self):
        return self.__method_name

    def associations(self):
        return self.__associations


if __name__ == "__main__":
    """
    TODO:
    * Make the command line options check nicer
    * Fix the hack for adding a specified output path
    """
    import sys
    import subprocess

    if len(sys.argv) < 4:
        print "Usage:"
        print "template_generator <introspection XML file> <data associations json file> <output directory>"
        exit()

    xml_file_path = sys.argv[1]
    json_file_path = sys.argv[2]
    data = None
    with open(xml_file_path, "r") as fh:
        data = fh.read()
    introspected = Introspected(data)
    creator = Template(introspected)
    with open(json_file_path, "r") as fh:
        json_string = fh.read()
    associations = create_associations(json_string)
    creator.apply_data_associations(associations)
    template = creator.create_template()
    path_parts = xml_file_path.split("/")

    # find name of introspection XML file
    name_with_extension = path_parts.pop()
    name_without_extension = name_with_extension.split(".")[0]

    # re-create original path to file
    path = "".join([part + "/" for part in path_parts])

    # create created python template file name
    template_file = name_without_extension + ".py"

    # create full path to new file
    template_file_path = sys.argv[3] + "/" + template_file

    #print template

    with open(template_file_path, "w") as fh:
        fh.write(template)
